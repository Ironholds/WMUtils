% Generated by roxygen2 (4.0.2): do not edit by hand
\name{keysplit}
\alias{keysplit}
\title{keysplit}
\usage{
keysplit(obj, key_col, pieces = round(detectCores()/4))
}
\arguments{
\item{obj}{the data.frame or data.table. In the event that it's a data.frame, it will be coerced into a
data.table}

\item{key_col}{the column storing the key.}

\item{pieces}{how many pieces to split \code{obj} into. By default it's a quarter of the available physical
CPU cores, rounded, since the intent is for \code{keysplit} to be used in relation to parallel processing.}
}
\description{
split a data.frame or data.table for parallel processing over a key column
}
\details{
Splitting a data frame into a list is easy, which is good; when you're performing listwise operations,
particularly through the parallel package, a list is the class of choice. Splitting a data.frame into a list
when you want to keep all the rows associated with unique values in a column together is /difficult/.

\code{keysplit} handles this; given a data.frame or data.table and the name of a column that contains
a key, it splits the object into a list, making sure that all rows associated with a specific key value
are found in the same list element each time.
}
\seealso{
\code{\link{parlapply}} a wrapper for the parallelised lapply function.
}

