# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'@title extract_mcc
#'@description extract a mobile carrier code (mcc) from an x_analytics header
#'@details \code{\link{extract_mcc}} grabs a mobile carrier code and associated country code
#'from an x_analytics field, where such a code is present (i.e., requests from Zero)
#'
#'@param x_analytics a vector of x_analytics fields
#'
#'@return a vector of empty strings or MCC codes, depending on if an MCC was found.
#'
#'@export
extract_mcc <- function(x_analytics) {
    .Call('WMUtils_extract_mcc', PACKAGE = 'WMUtils', x_analytics)
}

c_geo_country <- function(ip_addresses) {
    .Call('WMUtils_c_geo_country', PACKAGE = 'WMUtils', ip_addresses)
}

#' @title
#' session_count
#' @description
#' Session counting function
#' 
#' @param x a vector of intertime values
#' 
#' @param local_minimum the threshold (in seconds) to split out a new session on. Set to 3600
#' by default.
#' 
#' @details
#' \code{session_count} takes a vector of intertime values (generated via \code{\link{intertimes}},
#' or in any other way you see fit) and returns the total number of sessions within that dataset.
#' It's implimented in C++, providing a (small) increase in speed over the R equivalent.
#' 
#' @seealso
#' \code{\link{intertimes}}, for generating inter-time values,or \code{\link{session_length}} for
#' session length, in seconds.
#' 
#' @export
session_count <- function(x, local_minimum = 3600L) {
    .Call('WMUtils_session_count', PACKAGE = 'WMUtils', x, local_minimum)
}

#'@title
#'session_length
#'
#'@description
#'Session counting function
#' 
#'@param intertimes a vector of inter-time values.
#' 
#'@param local_minimum the threshold (in seconds) to split out a new session on. Set to 3600
#' by default.
#'
#'@param average_intertime the average time between events within a session, used to handle missing values
#'(time associated with the first request in a series of intertime pairs, for example). Set to 430 seconds
#'by default.
#'
#'@details
#'\code{session_length} takes a vector of intertime values (generated via \code{\link{intertimes}},
#'or in any other way you see fit), splits them into sessions, and calculates the approximate
#'length (in seconds) of each session. It's implemented in C++ since, even with the hinkiness
#'of my C++, it's still several OoM faster than the equivalent R (recursion in R is dumb).
#'
#'@return a vector of session length counts, in seconds.
#' 
#'@seealso
#'\code{\link{intertimes}}, for generating inter-time values, and \code{\link{session_count}} for
#'simply counting the number of sessions.
#' 
#'@export
session_length <- function(intertimes, local_minimum = 3600L, average_intertime = 430L) {
    .Call('WMUtils_session_length', PACKAGE = 'WMUtils', intertimes, local_minimum, average_intertime)
}

#'@title session_pages
#'@description count the number of pages in a session (or multiple sessions)
#'
#'@details \code{session_pages} counts the number of pages in a session, or in multiple
#'sessions, based on a provided numeric vector of intertime values, which can be
#'generated via \code{\link{intertimes}}.
#'
#'@param intertimes a vector of intertime values.
#'
#'@param local_minimum the threshold at which to split a series of intertime values into
#'multiple sessions. Set to 3600 seconds (1 hour) by default.
#'
#'@seealso \code{\link{intertimes}} for generating intertime values, \code{\link{session_length}}
#'for session length, and \code{\link{session_count}} for the number of distinct sessions represented
#'by a series of intertime values.
#'
#'@export
session_pages <- function(intertimes, local_minimum = 3600L) {
    .Call('WMUtils_session_pages', PACKAGE = 'WMUtils', intertimes, local_minimum)
}

cpp_intertimes <- function(timestamps) {
    .Call('WMUtils_cpp_intertimes', PACKAGE = 'WMUtils', timestamps)
}

#'@title host_handler
#'@details extracts the hostname, TLD and subdomains from a generic URL
#'
#'@description
#'\code{host_handler} is a domain-neutral host extractor for URLs, excluding generic prefixes (http, https, www)
#'and paths/queries.
#'
#'@param urls a character vector of URLs
#'
#'@return a vector of hostnames, or "Unknown" if the hostname was invalid
#'
#'@seealso \code{\link{project_extractor}} for extracting Wikimedia language codes and projects.
#'@export
host_handler <- function(urls) {
    .Call('WMUtils_host_handler', PACKAGE = 'WMUtils', urls)
}

#'@title project_extractor
#'@description extracts language and project from a Wikimedia URL
#'
#'@details \code{project_extractor} takes Wikimedia URLs and extracts the language and project
#'(for example, turning "https://en.wikipedia.org"" into "en.wikipedia"). It can handle both current
#'and historic intermediary domains - zero, mobile, wap - and exclude them consistently.
#'
#'@param urls a vector of URLs
#'
#'@return a vector of language and project names, or "Unknown" if a URL cannot be parsed. In the event
#'that a URL can be parsed but you've been silly enough to pass it a non-Wikimedia URL, it will simply
#'return nonsense.
#'
#'@seealso \code{\link{host_handler}} for extracting hostnames generically.
#'@export
project_extractor <- function(urls) {
    .Call('WMUtils_project_extractor', PACKAGE = 'WMUtils', urls)
}

#'@title parse_uuids
#'@description parse App UUIDs out of requestlog URLs
#'
#'@details \code{parse_uuids} takes URLs from the request logs and parses through them hunting for
#'the unique identifiers included in API requests by the Wikimedia Apps. These are then extracted and provided
#'as a vector.
#'
#'In the event that a valid ID cannot be identified, the string "Invalid" is instead returned.
#'
#'@param url_strings a vector of URLs from the request logs.
#'
#'@return a vector of unique IDs, or the string "Invalid" where no valid ID could be identified.
#'
#'@seealso \code{\link{sampled_logs}} and \code{\link{hive_query}} for retrieving request logs;
#'\code{\link{log_strptime}} for handling request log date/times.
#'
#'@export
parse_uuids <- function(urls) {
    .Call('WMUtils_parse_uuids', PACKAGE = 'WMUtils', urls)
}

#'@title xff_handler
#'@description extracts the last IP address from a chain of IPs reported through the x_forwarded_for field
#'
#'@details our x_forwarded_for fields contain not just single IP addresses, but sometimes /chains/ of IP addresses,
#'where users have gone through multiple levels of proxying. \code{xff_handler} extracts the earliest IP address in
#'such chains or, when a chain is not present, simply returns the (only) IP found. It is called in the various
#'geolocation functions in WMUtils, but may also be useful for extracting IPs in the case of (for example)
#'generating pseudo-unique fingerprints.
#'
#'@param ips a vector of IP chains
#'
#'@return a vector of either the last IP in a chain, or the IP if no chain was present.
#'
#'@export
xff_handler <- function(ips) {
    .Call('WMUtils_xff_handler', PACKAGE = 'WMUtils', ips)
}

